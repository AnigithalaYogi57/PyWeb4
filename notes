what does a software engineer do?

software engineer design and create applicatins to solve the real world problems
software developers
two categories
Front-end developer, Back-end developer,
Front end:HTML, css, bootstrap, javascript, angular, react etc..
Backend: python, django, drf, database

How to become a software engineer?
You can build new skills
Learn --> practice --> attending the interview --> get job.
what are the prerequisites?
must have any degree
decide the skills
must have desktop/laptop
managable english communication
zeal to learn and have to interest

why learn from me?
i will make you understand better
i am taking less fee
installment
i will give guidance
i will motivate the students

Python Introduction:
---------------------
Python is a general purpose high level programming language.

python was developed by Guido van rossam in 1989 while working at national research inst. at netherlands

but officially python was made available to public 1991
D.O.B: Feb 20th 1991

Free and open-source - you can freely use and distribute python. even for commercical use

Easy to learn - python has a very simple synatx.

portable - You can move python programs from one platform to another and run it without any changes

python is recommended as first programming language for beginners.

why learn python?
-----------------
Python is easy to learn, its syntax is easy and code is very readable
python has a lot of applications, it is used for developing, web, desktop, data science, ai, gaming, networking etc..

python allows you to write programms in fewer lines of code than most of the programming languages.

python popularity is growing rapidly.

To print Hello world

Java
----
public class HelloWorld
{
	public static void main(string[] args)
	{
	system.out.println("Hello world");
	}
}

C:
----
#include<stdio.h>
void main()
{
	print("Hello world");
}

python:
-------
print("Hello World")

Getting Started:
-----------------
https://www.python.org/downloads/

download the source file and install

cmd promt

python --version

IDLE(Integrated development learning environment)

vs code
pycharm
atom
eclipse

The name python was selected from the tv show

"The complete montty python's circus" which was broadcasted in bbc channel from 1969 to 1974.


Guido developed python language by taking alomost all programming features form different languages

1. Functional programming features from C
2. Object oriented programming features from C++
3.scripting features from perl and shell script

where we can use python?
-------------------------
1.For developing desktop applications
2.web applications
3.database applications
4.networking prgram
5.developing games
6.data analaysis
7.machine learning
8.AI
9.IOT
etc...

Note:

Internally Google and Youtube use python coding
NASA and NSE applications by python
Top software comapniess like google, microsoft, ibm, yahoo. using python

Identifiers:
-------------
A name in python programme is called identifier

a=100
x='yogi'
d=10.5

def testfunc():
    pass

def 1test():  // not valid identifier
    pass

class Student:
     pass

It can be class name or function name or module name or a variable name

Rules to define identifier in python:
--------------------------------------
1. The only allowed characters in python are:
    ->alphabet symbols(lower/upper)
    ->digits(0-9)
    -> underscore symbol(_)

    cash = 100
    ca$h = 200 (X)
    ca_h = 300
2. Identifier should not start with digit

    123total (X)
    total123

3. Identifiers are case sensitive, bcz python is case sensitive.

  a=100
  print(a)
  print(A) (X)

  _total = 100
  if identifier is starts with underscore then it indicates it is private

4. we can not use reserved words as identifier

   def = 200 (X)
   class =300 (X)

5 There is no length limit for identifier but not recommended use lengthy identifiers.

   a=100
   dfsdhfsdgfgfgfdlfhasdlfsf = 100

java2share  #valid
ca^p        #not valid
_abc_abc_   #valid
def         #not valid
if          #not valid
else        #not valid
1ten        #not valid

Reserved words:
---------------
python has a set of keywords that are reserved words that can not be used as variable names,
function names, or any other identifiers

[
    'False',
    'None',
    'True',
    'and',
    'as',
    'assert',
    'async',
    'await',
    'break',
    'class',
    'continue',
    'def',
    'del',
    'elif',
    'else',
    'except',
    'finally',
    'for',
    'from',
    'global',
    'if',
    'import',
    'in',
    'is',
    'lambda',
    'nonlocal',
    'not',
    'or',
    'pass',
    'raise',
    'return',
    'try',
    'while',
    'with',
    'yield'
]

Note: Except 3 reserved words all contains lower alphabets
True, False, None

Data Types:
-----------
a=1000
Data type represent the type of data present inside a variable

In python we are not required to specify the type explicitly

int a = 1000
float b = 10.5

based on the value provided the type will be assigned automatically.
Hence python is Dynamically typed language.

a=1000
b=10.5
c='yogi'
d=True

**Every data type in python is internally implemented as a class

Data types are categarized into different ways:
 1. fundamental data types
 2. Collection data types

 Fundamental data types:
 ------------------------
 Fundamental data types reprasented classes/objects are storing only one value.

object means memory location
 a=100

 eg: int, float, complex, bool, str

 Collection data types:
 ----------------------
 collection type represented classes/objects are stored in group of elements these objects
 are iterable objects

a=10,20,30

every collection type class provides methods to perform operations on elements of those objects.

Eg: list, tuple, set, dict

python contains several inbuilt functions

1.type() --> to check the type of variable
2.id()  --> to get address of object
3.print() --> to print the value

int data type:
--------------
we can use int data type to represent whole numbers(integral values)
eg:
   a = 10
   type(a) ==> <class int>

float data type:
---------------
we can use int data type to represent floating point values(decimal values)
eg:
   f=1.3445
   type(f)  ==> <class float>

complex data type:
------------------
a+bj

a --> real part, b--> imaginary part

3+5j, 10+5.5j, 0.5+0.1j

bool data type:
---------------
we can use int data type to represent boolean values
allowed values are True and False

str type:
---------
A string is sequance of characters enclosed within single quotes or double quotes
s1='yogi' s1="yogi"

Immutable and mutable objects
-----------------------------
Immutable objects:
------------------
The objects which doesn't allow to modify the contents of those objects are known as
Immutable objects


a=10
b=10
c=10

before creating Immutable objects with some content python intrepretor verifies is already
any object is available in memory location with same content or not

if already object is present in memory location with the same content without creating a new
object already existing object address will be given to the reference variable

* all the fundamental data types and tuple are the Immutable objects

* Immutable objects performance is high

* applying iterations on Immutable objects takes less time

mutable objects:
----------------
The objects which allows to modify the content of those objects are known as mutable objects

we can create two different mutable objects with the same content

l=[10,20,30]
x=[10,20,30]
* list, set, dict are the mutable objects
* mutable objects performance is low when compare to Immutable objects
* applying iterations on mutable objects tekes huge time

string Handling:
----------------
Group of characters or sequance of characters is known as string

strings stored in str class object

str class objects can be created in two ways

1.single quotes ' '   or " "
2.triple quotes ''' '''  or """ """

a='yogi' or "yogi"
b='''yogi''' or """yogi"""

single quotes to represent one line string

triple quotes is used to represent multiple line string

every character is reprasented with unque index

it supporting both positive and negative index

positive indexing starts from 0  and negative indexing starts -1

by using the indexing we can read the data from string


iterable objects has predefined function i.e len()

iterable objects are str, list, tuple, set, dict

len() is a builtin function is used to count the number of characters

Reading the data from keyboard:
-------------------------------
we can read the data from the keyboard by calling input() function

input function is predefined function which reads the data in the form of string format only.

Type casting / type conversion:
===============================
int, float, bool, complex, str

input() function reads in the str form

int(a)

float(a)

bool(a)

complex(a)

git:
=====

pushing the code to git repository:
-----------------------------------
--------First Time push the code from New Folder--------
-> open git bash here in new folder
-> git init
-> git add .
-> git commit -m "first commit"
-> git remote add origin '<git url>'
-> git push -u origin master

-----Next All Time from same folder-----
git add .
git commit -m "first commit"
git push

Pull the code from git repository:
-----------------------------------
--------First Time pull the code from git--------

git clone <git url>

-----Next All Time-----
git pull


operators:
----------
operators are the special symbols which are used to perform the operations on the data of the
objects which are pointed by the operands

a=10
b=20

special symbols + , - etc..

python supports fallowing types of operators:

Arthimetic operators
comparision operators
logical (boolean) operators
Bitwise operators
Assignment operators
special operators

Arthimetic operators:
----------------------
Arthimetic operators are used to perform the mathematical operations like
addition, subtaction, multiplication, division, floor division, modulus and exponential

x=15
y=4

comparision operators:
---------------------
comparision operators are used to compare the data of the objects which are pointed by the operands

eg: > , < , ==, !=, >=, <=
x=10
y=12

logical (boolean) operators:
----------------------------
logical operators are used to perform the mathematical logical operations

logical operators are: and , or, not

x=True
y=False

Bitwise operators:
------------------
Bitwise operators converts the data in the form of binary format and performs the operations
on the binary data
bitwise operator gives the results in the form of decimal format

bitwise operators are : & , | , ^ , ~ , >> , <<

x=10
y=4

Assignment operators:
---------------------
Assignment operators are used to assign the data into the variable

eg: a=100
+=, -=, *=, /= etc..

Operator                            Example                            Equivalent to
_________________________________________________________________________________________

 =                                   x=5                                   x=5
 +=                                  x+=5                                  x=x+5
 -=                                  x-=5                                  x=x-5
 *=                                  x*=5                                  x=x*5
 /=                                  x/=5                                  x=x/5
 %=                                  x%=5                                  x=x%5
 //=                                 x//=5                                 x=x//5
 **=                                 x**=5                                 x=x**5
 &=                                  x&=5                                  x=x&5
 |=                                  x|=5                                  x=x|5
 ^=                                  x^=5                                  x=x^5
 >>=                                 x>>=5                                 x=x>>5
 <<=                                 x<<=5                                 x=x<<5
_________________________________________________________________________________________

special operators:
------------------
python supports two typs of special operators they are:

1. identity operators
2. membership operators

Identity operator:
------------------
identity operators are used to compare the address of the objects, which are pointed by the operands

eg: operators are is, is not

i=10
j=10

i is j ==> True
i is not j  ==> False

Membership operators:
----------------------
Membership operators are used to search for the required element in the given iterable object.

eg: operators are in, not in

'g' in 'yogi'
'l' in 'yogi'
's' not in 'yogi'
'i' not in 'yogi'

control flow statements:
-----------------------
By default python program execution starts from 1st line, executes each and every statements only once
and terminates if the last statement of the programme execution is over

control flow statements are used to distrub the normal flow of the execution of the programme

two types of control flow statements:
1. conditional statement
2. looping statement

conditional statement:
----------------------
conditional statements are used to decide whether block as to execute or skip the execution of the block

Three conditional statements are if, else, elif

if:
---
 syntax:
           if condition: statement
           		or
           	if condition:
           		stm1
           		stm2
           		stm3
           		----
           		----
    condition returns True it executes the block otherwise skip the execution of the block

else:
-----
else block should be preceeded by if block or elif block or while block or for block

If else block preceeding block condition is returning False then only else block will be executed

elif:
-----

elif should be preceeded by the either if block or another elif block

looping statement:
------------------
looping statements are used to execute set of statements repeatedly

python supports two looping statements they are

1. while
2. for

while:
------
while loop executes set of statements repeatedly until condition becomes false

syntax:
            while condition:
            	stm1
            	stm2
            	stm3
            	----
            	----
break:
-------
break is a statement which can be used in looping statements whenever control reach to the break
statement of the loop then without executing the loop control will comes out from the loop

continue:
---------
continue is a statement which can be used in looping statements
whenever control reach to the continue statement of the looping statements
then without executing the remaining part of the iteration control will go to the next

for loop:
---------
for loop executes set of statements with respect to every element of the given iterable object

syntax:
           for var in iterableObject:
           	    ---------------
           	    ---------------
           	    --------------
           	    --------------

range() is a function to generate sequance of numbers starting from 0 and stops before specified number

syntax:
          range(start, stop, step)

range(10) => 10 is stop
range(2,10) => 2 is start and 10 is stop
range(1,13,2) => 1 is start, 13 is stop and 2 is step


Q) Using for loop w.a.p to calculate the first N natural numbers sum

methods of string:
------------------
capitalize()
title()
upper()
lower()
isdigit()
split()

collections:
------------
collection types reprasented classes or objects are stored in group of elements(objects)
collection types reprasented classes objects are iterable objects
every class provides methods to perform operations on elements.

python supports fallowing collection types:
list
tuple
set
dict

LIST:
-----
list objects can be created by using square brackets or by calling list function

eg:  a=[] or a=list()
-> list objects are mutable objects
-> insertion order is preserved
-> Heterogenious elements are allowed
-> duplicates elements are allowed
-> every element in the list represented with unique index
-> list supports both positive and negative indexing
-> the elements of the list can be mutable or Immutable

x=[10,20,30,40,50,60]
print(x)
s=0
for i in x:
    s+=i
    #s=s+i
print(s)

#sum try with while loop

Nested list:
------------
A list inside a list is called a nested list

x = [[10,20,30],[40,50,60],[70,80,90]]

unpacking the elements:
------------------------

a= x[0]
b= x[1]
c= x[2]

a,b,c = x

working with methods of list:
-----------------------------
x=[10,20,30,40,50,60]

append, count, index, copy, insert, remove, pop, extend, sort, reverse, clear

append : add the element to last position

count : returns number of occurances

index : returns first occurance value index position

copy : copy the list

insert : inserting a value in a perticluar index position  => insert(index,value)

remove : removes the first occurance element from a list

pop : removes the element by index position, default last index position value removes

extend : extending the existing list with another list

sort : sort the elements ascending/ descending

reverse : existing elements order reverse

clear : empty the list

To known the class description we can use a inbuilt function is help(classname)

Q) take a some duplicate elements of list and create a new list witout having duplicates

x=[1,2,1,3,4,2,4,5,7,8,9,64,457,98,2,3,56,79,9,1,2,4,8,9,10]

List comprhension:
-----------------
The concept of generating the elements into the list object by writing some logic in the list
is known as a list comprhension

eg: x = [p for p in range(1,11)]
print(x) => [1,2,3,4,5,6,7,8,9,10]

tuple class:
------------
tuple objects can be created by using parenthesis or by calling tuple function or by assigning
multiple values to a single variable

eg:
       t = () or t=tuple() or t=1,2,3

*tuple objects are Immutable objects
*insertion order is preserved
*duplicates elements are allowed
*Heterogenious elements are allowed
*tuple supports both positive and negative indexing
*the elements of the tuple can be mutable or Immutable

methods of tuple:
index, count

Q) find the sum of elements of a tuple 1)using for loop, 2) using while loop
x=(10,20,30,40,50,60)

total = 210

nested tuple:
------------
A tuple inside a tuple is called a nested tuple

x = ((10,20,30),(40,50,60),(70,80,90))

Differences b/w list and tuple:
-------------------------------

List                                                         Tuple
-----                                                       -------
list objects are mutable objects                       immutable objects

Applying iteration on list takes longer time           on tuple takes less time

if the frequent operation is insertion or deletion     if the frequent operation is retrival of the elements
of the elements it is recomended                           it is recomended

list can not used as a key for the dictionary           tuple can be used as a key for the dictionary if tuple
                                                          is storing only immutable elements

set class:
----------
set objects can be created by using curly braces {1,2} or by calling set() function

* set objects are mutable objects
* elements of the set must be immutable
* insertion order is not preserved in set
* duplicates elements are not allowed
* Heterogenious elements are allowed in set
* set is not supporting indexing

tuple can be stored in a set, because tuple is a immutable object

if tuple contains immutable elements then only we can use the tuple in the set

methods of set:
---------------
add, copy, remove, pop, discard, clear

discard method will not display any error if given no is not in set
remove method will display key error if given no is not in set
pop method will remove the first element from the set

mathematical set operations
union, intersection, difference, symmetric-difference

set comprhension:
-----------------
The concept of generating the elements into the set object by writing some logic in the set
is known as set comprhension

x={p for p in range(10)}

dictionary:
-----------
dictionary objects can be created by using curly braces { } or by calling dict() function

dictionary objects are mutable objects

dictionary elements represents key-value base

item: each key-value pair is known as item

dictionary keys must be immutable

dictionary values can be mutable or Immutable

duplicates keys are not allowed but values can be duplicate

insertion order is not preserved

Heterogenious keys and Heterogenious values are allowed

key and values are seperated with ':'
items are seperated with ','

methods of dictionary:
---------------------
update, get, pop, popitem, keys, values, items


Q) calculate sum of the dictionary values
x={'python':99,'java':90,'oracle':82,'django':97}

dictionary comprhension:
------------------------
The concept of generating items into the dictionary by writing some logic in the dictionary
is known as a dictionary

Ex: x = {p:p*p for p in range(5)}

Q) take two dictionarys with same keys and different values then do the sum of values of same key.
p={'a':24,'b':16,'c':8}
q={'a':12,'b':18,'c':19}
req output is :
a=36
b=34
c=27

Functions:
---------
Function is a syntax or structure is used to represent the buisiness logic to perform the operation

*Function will not be executed automatically
*Function will be executed whenever we make a function call
*one function we call for n number of times

syntax:
              def functionName(var1, var2, var3, .....):
              	""" doc str """

              	---------------
              	-----logic-----
              	---------------

              	return value

Document string:
---------------
* document string is used to provide the description about the function

* with in the function document string is optional but it is recomended to define
  document string in the function

def testfunc():
	""" this is a testfunc to test the doc string """
	print("i am in testfunc")

Parameters:
-----------
The variables which are declared within the function declaration are known as Parameters

At the time of function calling we have to pass the values to the Parameters

within the function declaration Parameters are optional

python supports two types of Parameters
1) Non default Parameters
2) default Parameters

Non default Parameters:
----------------------
The Parameters which are declared without assigning any value are known as non default Parameters

no values assigned in the function declaration

At the time of calling the function we should pass values of the non default Parameters

eg:
       def f1(a,b,c):
       	pass
       here a,b,c are the non default Parameters
default Parameters
------------------
The Parameters which are declared by assigning some value are known as default Parameters

values assigned into variables in the function declaration

At the time of calling the function we need not to pass the values to the default Parameters of a function

eg:
        def f1(a=1,b=2,c=3):
        	pass

        here a,b,c are the default Parameters

Note:
After defining the default Parameters we are not allowed to define non default Parameters

Arguments:
----------
The values which are passing to the Parameters of a function at the time of calling the function
are known as Arguments

python supports two types of Arguments they are:
1. Non keyword Arguments
2. keyword Arguments

Non keyword Arguments:
-----------------------
The Arguments which are passed without assigning to the Parameters are known as non keyword Arguments

eg:
           def add(p,q):
           	c=p+q
           	print(c)

           add(2,1)

keyword Arguments:
------------------
The Arguments which are passed by assigning to Parameters name are known as keyword Arguments

eg:
           def add(p,q):
           	c=p+q
           	print(c)

           add(q=2,p=1)


Note:
-----
After defining keyword Arguments we are not allowed to define no

Orbitary Parameters:
--------------------
The Parameters which are preceeded by star(*) are known as Orbitary Parameters

At the time of calling the function we can pass zero or more values(Arguments) to the Orbitary Parameters

*Parameter type internally taken as tuple

eg:
     def add(*a):
     	print(a)
     	print(type(a))
     	print(sum(a))


**Parameter type internally taken as dictionary


Note: in Orbitary Parameters name can be any. but all are using/recomended to use
Parameters are *args and **kwargs

non keyword Arguments are stored in *args
keyword Arguments are stored in **kwargs

return statement:
-----------------
we can define n number of return statements in a function

whenever control reach to the return statement of a function then without executing remaining
part of the function control will come out from the function execution by returning some value

the return value of the function can be stored into a variable
we can use that variable in the remaining part of the

if we are not storing the return value of a function in any value then the data
will become as a garbbage collection

by default every function will return None

why the function is executed only function call?
------------------------------------------------
For every function internally one object is created, store that object address into the
function name reprasented variable and we can call that function through that variable

eg:       def myfunc():
             print("welcom")


          print(myfunc)

we can copy the function object into other variable and we can call that function through that
variable

Global variables:
-----------------
The variables which are declared outside of the all the functions are known as Global variables

Global variable of one program can be accessed within all the functions of the same program

Global variables of a program memory will be allocated only once

Local variable:
---------------
The variables which are declared within the function are known as local variables

local variables of one function can't be accessed outside of that function

for all the local variables of a function memory will be allocated with respect to every time
function

* inorder to modify the Global variable values with in the function we should define
forward declaration of Global variables

global keyword to define farward declaration of Global variable

eg: a=1000

synatx:      global a
             a=5000

Recursive Function:
-------------------

A function which is called by itself is known as a Recursive Function

infinite Recursive is not supported by python


def f1():
	print("i am in f1")
	f1()

Ananymous function or lambda function:
======================================
a function which doesn't contain any name is known as a Ananymous function or lambda function

syntax:
--------

        lambda arguments : expression


lambda function we can assign to the variable and we can call the lambda function through the
variable

var = lambda arguments : expression

var()

predefined functions: filter, map, reduce

filter function takes two Arguments lambda function and iterable_object

filter gives the values based on the condition whether it is true or false it displays only
True values

map function takes two Arguments lambda function and iterable_object

my_list = ['1','5','4','6','8','11','13','12']
new_list = list(map(lambda x:int(x)*int(x), my_list))
print(new_list)

map gives the values based on the expression whether it is true or false it displays both
True and False values

Q) try same thing without using filter and map, using normal function logic


reduce function takes two Arguments lambda function and iterable_object

modules-imports:
----------------
Every python file itself is known as a module
a module can contain global variables executable statements, functions and classes

The Properties of one module we can use into another module by using import statement

python supports two types of import statements

1. normal import
2. from import


normal import:
--------------
In normal import entire python file or module object is imported

whenever we import a module by using normal import statement we can access the Properties
of that module by using module name

At the time of importing a module by using normal import statement we can create the alias name
 for the module and we can access the Properties of that module through alias name

from import:
-----------
by using from import we can import the required Properties of a module

The Properties which are imported by using from import we can access those Properties directly
without using module name


Built-in module:
----------------
built in is a predefined module which contains frequently used functions
python intrepretor imports built in module for each and every python file automatically

we can use the Properties of built in modules directly without importing builtin modules explicitly

eg: len, range, input

modules search path:
-------------------
by default python intrepretor search for the imported modules in the fallowing location:

1) current directory (main module directory)
2) environment variable path
3) Installation dependent directory (Lib)

if imported module is not found in the any one of the above locations then python intrepretor
gives an error called module not found error

Packages:
---------
Package is nothing but a folder or directory which represents collection of modules along with
__init__.py module

a Package can also contain sub Packages

we can import the modules of the Package by using

  import PackageName.subpackageName.moduleName as modName
  from PackageName.subpackageName.moduleName import propertyName


File Handling:
-------------
File is a named location on the disk, wich stores the data in permanent manner

python language provides various functions and methods to provide the communication between python
programes and files

python programes can open the file, perform the read or write operations on the file and close the file

we can open the file by calling open() function of built in modules

At the time of opening the file, we have to specify the mode of the file

mode of the file indicates for what purpose the file is going to be opened (r,w,a,b)

                  File modes
                  ----------

'r' --> open a file for reading (default)

'w' --> open a file for writing. creates a new file if it does not exist or truncates the file
                    if it is exist

'a' --> open for appending at the end of the file without trucating it, creates a new file
                    if does not exist

't' --> open in text mode

'b' --> open in binary mode


open function open the file in the specified mode and creates file object

file object provides various methods and by using those methods we can perform the read or write
operations on the files and we can close the files

write() --> to write the data into a file
read() --> read the data from a file
tell() --> to find the cursor position
seek(8) --> to read the data form 8th position
readline() --> returns first line of a file
readlines() --> returns a list of lines

Q) reverse a word, last line of last word of a file
Q) reverse the words of first line of a file
eg: i/p "my name is yogi" o/p "yogi is name my"


Exception Handling:
-------------------
generally we get two types of errors in programming languages they are:

1.syntax errors
2.runtime errors

synatax erros:
-------------
The erros which occures because of invalid synataxes is known as synatax erros

whenever synatax error is occured in python programe, then compiled python file will not be
generated

without getting compiled python file programe execution will not be started

programer is responsible for providing the solution to the synatax erros

eg: print('yogi'))

Run time erros:
--------------
The erros which occures After starting the execution of the programe are known as runtime errors

Runtime errors can occure because of
1 invalid input
2 invalid logic
3 memory issues
4 harware failures and so on
with respect to every reason which causes to runtime error

corresponding runtime error represented class is avialable

runtime error represented classes technically known as a exception classes

while executing the programe if any runtime error is occured corresponding exception class object
is created

creating exception class object is technically known as a raising exception

while executing the programe if any exception is raised then internally python intrepreter
verifies any code is implemented to handle the raised exception or not

If code is not implemented to handle raised exception then programe will be terminated abnormally

Abnormal termination:
--------------------
The concept of terminating the programe in the middle of its execution without executing last statement
of the module is known as a abnormal termination

Abnormal termination is undesirable situation in programming languages

Exception Handling:
-------------------
The concept of identifying raised exception, receiving that exception and assigning that exception
to corresponding exceptional class is known as exception Handling

identifying exception
receiving exception
assigning exception class

Exception Handling can be implemented by using try and except blocks

Try block:
-----------
A block which is preceded by the try keyword is known as a try block

synatax:
            try:
              ----
              ----
              ----

The statements which causes to runtime errors and other statements which depends on the
execution of runtime errors statements are recomended to represent in try block

while executing try block statement if any exception is raised then immediately try block identifies
that exception, recieves that exception and forward that exception to except block without executing
remaining statements to try block

Except block:
--------------
A block which is preceded by the except keyword is known as except block

except block should be preceded by try block

synatax:
-------
      except Exception_class:
        ---------------
        --------------
        ------------

except block requires the exception object given by try block and assign that exception to corresponding
exception class

in except block we can also define the statements to display the user friendly error messages

if exception is raised in try block statements then only control comes to the except block


default except class:
---------------------
default except block is a except block which can handle any type of exception
syntax:

        except:
        	-----
        	-----
        	-----

single try with multiple except blocks
--------------------------------------
To handle the different exceptions by using different except block we use single try
in multiple except blocks

if any exception is raised in try block then control goes to the first except block

if the first except block is not handle the exception then only control will goes to the next
except block

Note:
-----
while defining single try with multiple except blocks default except block should be the last except
block otherwise we get synatax error

Finally block:
--------------
A block which is preceded by the finally keyword is known as a finally block

synatax:
           finaly:
              ---
              ---

finaly block should be preceded by either try block or except block

The set of statements which are compulsory to excecute whether exception is raised or not raised even though raised exception
whether it is handled or not handled are recomended to represent in finally block

resource releasing statements (file closing statements) or data base connection close statements
 are recomended to represent in finally block

Nested try blocks
-----------------
The concept of defining one try block inside another try block is known as nested
  try block

outer try block

inner try block


try:
  statement1
  statement2
  try:
    stmt1
    stmt2
    stmt3
  except ZeroDivisionError:
    inner try except
  except:
    inner try except
except ValueError:
  outer try except
except:
  outer try except

If the exception is raised in inner try block then control goes to inner except block

if inner except block is not handle that exception then control will goes to outer
 except block

Userdefined exceptions:
-----------------------
The exceptions which are defined by the programmers explicitly according to their buisiness requirements
 are known as Userdefined exceptions

steps to implement user defined exception:
------------------------------------------

1. defining user defined exception class
defining any user defined class by extending any one of the predefined exception class is known
as user defined exception class

2. Raising exception:
creating exception class object by using raise keyword is known as a raising exception

3. Handling the raised exception:
we can handle the raised exception by using try & except blocks


class ValueTooSmallError(TypeError):
  pass

class ValueTooLargeError(Exception):
  pass

Q) count the number of vowels in a given sentance
i/p : "Hello, have you tried our tutorial section yet?"

Q) check a string is palindrome or not
A palindrome is a string which is same read forward or backward

aba == aba
abca != acba

Q) check a number is Armstrong number

if we calculate for 3 digit number then the addition of the cube of each digit sum is equal to
the corresponding number

153 ==> 1^3 + 5^3 + 3^3 =153

Object oriented programme principles:
-------------------------------------
oops principles are nothing but certain rules or guidelines.

Different oops principles are:
1.Encapsulation
2.Inheritance
3.polymorphism
4.Abstraction

if we implement buisiness applications in any programming language according to oops principles
Then we will get the security, flexibility and reusability in those applications.

Object Oriented Programming languages:
-------------------------------------
Any programming language which provides special synataxes to implement the applications in those
languages according to the oops principle is known as object oriented programming language

ex:  c++, java, .net, python etc...

procedure oriented vs Object Oriented

example for procedure oriented:

cname=None
cadd=None
cacno=None
cbal=None
ename=None
eadd=None
eid=None
esal=None

def deposit():
  pass

def withdraw():
  pass

def transfer():
  pass

def balenq():
  pass

def da():
  pass

def hra():
  pass

def tax():
  pass

def esal():
  pass

in procedure oriented mechanism, security is missing for the global variables

Encapsulation:
-------------
The concept of binding or grouping related data members along with its releated functionalities
is known as a Encapsulation

eg: class

class:
------
class is a syntax or structure is used to group the releated members along with its releated
functionalities

syntax:
               class className:
               	''' doc string '''
               	-----------------
               	-----------------
               	-------data------
               	-----------------
               	-----------------

               	-----------------
               	-----------------
               	---functionalities-----
               	-----------------
               	-----------------


within the class we can represent the data by using variables
three types of variables:
1 static variables(class variables)
2 Non-static variables (instance variables)
3 Local variables

within the class we can represent the operations by using methods

doc string is used to provide the description about the class doc str is optional

object:
-------
 The concept of allocating memory space for members of a class at run time Dynamically is known
 as a object

 syntax:          pointer_var = className()

If u create an object, if the object is created with original address that variable is called
as pointer variable

References are used to refer an existing variable in another name eg: self

through the pointer variable we can put the data into the object
we can get the data from the object and we call the methods on the objects

we can create 'n' number of objects for a class

1 static variables/class variables:
-----------------------------------
The variables which are declared within the class and outside of all the methods are known
as static variables

class X:
  a=1000
  b=200
  def m1(self,a):
    pass
  def m2(self):
    pass

The data which is comman for all the objects is recomended to represent through static variables

class Customer:
  bname = "SBI"
  def m1(self):
    pass

c1 = Customer()
c2 = Customer()

static variables of a class memory will be allocated only once
static variables of a class, we can access within all the methods of a class through the class name
static variables of a class we can access outside of the class by using class name or through the object
If we apply abstraction on static variables we can access inside the class not outside of the class

Non-static variables(instance variables):
-----------------------------------------
The variables which are declared within the class by using(self.) are known as non-static variables

The data which is seperate for every object is recomended to represent through non-static variables

Non-static variables of a class memory will be allocated within the object

non static variables of a class we can access within the same class by using self.

non static variables of a class we can access outside of the class by using pointer_var

class X:
    a=1000
    b=2000

    def method1(self):
        self.p = 5000
        self.q = 6000
        print(self)
        print(X.a)
        print(X.b)
        print('non-static var',self.p)

    def method2(self):
        X.a = 3000
        X.b = 4000
        print(self.p)
        print(self.q)

x1=X()#object creation for class X
x1.method1()
print(x1.p)

whenever we define non static variables within the methods those non static variables will be
added to the object whenever we call that method

here in this case: without calling method1 if we call method2 Attribute error
x1.method2()  #Attribute error

constructors:
-------------
constructor is a special method

constructor name should be __init__(self)

constructor is used to define & initialize non static variables

class X:

  def __init__(self):
    self.a = 100
    self.b = 200
  def m1(self):
    pass


y1=X()
y1.m1()
y1.m1()
y2=X()


differences b/w methods and constructor
--------------------------------------

         method                                               constructor
         =======                                             ==============

method name can be any name                          constructor name should be __init__

method will be executed whenever we                  constructor will be executed automatically
call a method                                        whenever we create an object

with respect to one object one method                with respect to one object one constructor can be
can be called for n number of times                  executed only once

methods are used to represent the business           constructor is used to define &
logic to perform the operations                      initialize non static variables


Q) i will take one class and creates number of objects, find the count of objects.

c1=Customer()
c2=Customer()
c3=Customer()

print('count of objects:',3)

Local variables:
---------------
The variables which are declared within the method body are known as local variables

The data which is required to use within a perticluar method is recomended to represent
through local variables
